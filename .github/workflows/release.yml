name: Release Management

on:
  push:
    tags: ['v*']
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
        - pre-release
      create_release_notes:
        description: 'Create release notes automatically'
        required: true
        default: true
        type: boolean
      deploy_to_production:
        description: 'Deploy to production after release'
        required: true
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '8'

jobs:
  validate-release:
    name: Validate Release Request
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.validation.outputs.should_release }}
      release_version: ${{ steps.validation.outputs.release_version }}
      release_type: ${{ steps.validation.outputs.release_type }}
      is_prerelease: ${{ steps.validation.outputs.is_prerelease }}
      commit_sha: ${{ steps.validation.outputs.commit_sha }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate release request
      id: validation
      run: |
        SHOULD_RELEASE=false
        RELEASE_VERSION=""
        RELEASE_TYPE=""
        IS_PRERELEASE=false
        COMMIT_SHA="${{ github.sha }}"

        if [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          # Tag-based release
          RELEASE_VERSION="${GITHUB_REF#refs/tags/}"
          RELEASE_TYPE="tagged"
          SHOULD_RELEASE=true

          if [[ "$RELEASE_VERSION" =~ (alpha|beta|rc) ]]; then
            IS_PRERELEASE=true
          fi

          echo "Tagged release detected: $RELEASE_VERSION"
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual release
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"

            # Get current version from package.json
            CURRENT_VERSION=$(node -p "require('./package.json').version")

            # Calculate new version
            if [ "$RELEASE_TYPE" = "patch" ]; then
              RELEASE_VERSION=$(npm version patch --no-git-tag-version)
            elif [ "$RELEASE_TYPE" = "minor" ]; then
              RELEASE_VERSION=$(npm version minor --no-git-tag-version)
            elif [ "$RELEASE_TYPE" = "major" ]; then
              RELEASE_VERSION=$(npm version major --no-git-tag-version)
            elif [ "$RELEASE_TYPE" = "pre-release" ]; then
              RELEASE_VERSION="${CURRENT_VERSION}-$(date +%Y%m%d-%H%M%S)"
              IS_PRERELEASE=true
            fi

            SHOULD_RELEASE=true
            echo "Manual release requested: $RELEASE_VERSION ($RELEASE_TYPE)"
          else
            echo "Manual release only allowed from main branch"
            exit 1
          fi
        fi

        echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

    - name: Check CI status
      if: steps.validation.outputs.should_release == 'true'
      run: |
        echo "Checking CI status for commit ${{ steps.validation.outputs.commit_sha }}..."

        # Wait a moment for CI to potentially start
        sleep 30

        # Check if CI workflows have completed successfully
        CI_STATUS=$(gh run list --repo ${{ github.repository }} --head ${{ steps.validation.outputs.commit_sha }} --limit 5 --json status,conclusion --jq '.[0].conclusion' || echo "null")

        if [ "$CI_STATUS" != "success" ]; then
          echo "âŒ CI has not completed successfully. Please ensure all checks pass before releasing."
          echo "Current CI status: $CI_STATUS"
          exit 1
        fi

        echo "âœ… CI status validated"

  build-release:
    name: Build Release
    runs-on: ubuntu-latest
    needs: validate-release
    if: needs.validate-release.outputs.should_release == 'true'

    strategy:
      matrix:
        app: [web, api]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ needs.validate-release.outputs.commit_sha }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'

    - name: Install pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Update version in package.json
      run: |
        echo "Updating version to ${{ needs.validate-release.outputs.release_version }}"
        npm version ${{ needs.validate-release.outputs.release_version }} --no-git-tag-version

        # Update version in workspace packages
        pnpm update-version ${{ needs.validate-release.outputs.release_version }} || true

    - name: Build ${{ matrix.app }}
      run: |
        cd apps/${{ matrix.app }}

        # Set release environment variables
        export NODE_ENV=production
        export NEXT_PUBLIC_APP_ENV=production
        export NEXT_PUBLIC_APP_VERSION="${{ needs.validate-release.outputs.release_version }}"
        export NEXT_PUBLIC_BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

        pnpm ${{ matrix.app == 'web' && 'build' || 'build' }}

    - name: Generate build info
      run: |
        mkdir -p release-artifacts

        # Create build info file
        cat > release-artifacts/build-info-${{ matrix.app }}.json << EOF
        {
          "version": "${{ needs.validate-release.outputs.release_version }}",
          "commit": "${{ needs.validate-release.outputs.commit_sha }}",
          "build_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "app": "${{ matrix.app }}",
          "node_version": "$(node --version)",
          "pnpm_version": "$(pnpm --version)"
        }
        EOF

    - name: Create release package
      run: |
        mkdir -p release-packages/${{ matrix.app }}

        if [ "${{ matrix.app }}" = "web" ]; then
          cd apps/web
          tar -czf ../../release-packages/web/release-${{ needs.validate-release.outputs.release_version }}.tar.gz .next/
          cp ../../release-artifacts/build-info-web.json ../..
        else
          cd apps/api
          tar -czf ../../release-packages/api/release-${{ needs.validate-release.outputs.release_version }}.tar.gz dist/
          cp ../../release-artifacts/build-info-api.json ../..
        fi

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.app }}-release-build
        path: |
          release-packages/${{ matrix.app }}/
          release-artifacts/build-info-${{ matrix.app }}.json
        retention-days: 30

  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    needs: [validate-release, build-release]
    if: needs.validate-release.outputs.should_release == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate changelog
      run: |
        echo "Generating release notes for ${{ needs.validate-release.outputs.release_version }}..."

        # Get previous tag
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

        if [ -n "$PREVIOUS_TAG" ]; then
          echo "Comparing changes since $PREVIOUS_TAG"
          COMMIT_RANGE="$PREVIOUS_TAG..HEAD"
        else
          echo "No previous tag found, showing all changes"
          COMMIT_RANGE=""
        fi

        # Generate changelog
        cat > release-notes.md << EOF
        # Release ${{ needs.validate-release.outputs.release_version }}

        **Released**: $(date -u +%Y-%m-%d)
        **Commit**: ${{ needs.validate-release.outputs.commit_sha }}

        ## ðŸš€ Changes

        EOF

        # Get commit messages
        if [ -n "$COMMIT_RANGE" ]; then
          git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --no-merges >> release-notes.md
        else
          git log --pretty=format:"- %s (%h)" --no-merges -20 >> release-notes.md
        fi

        echo "" >> release-notes.md
        echo "## ðŸ“¦ Installation" >> release-notes.md
        echo "" >> release-notes.md
        echo "### Docker (Recommended)" >> release-notes.md
        echo "" >> release-notes.md
        echo "\`\`\`bash" >> release-notes.md
        echo "docker pull parsify/parsify:${{ needs.validate-release.outputs.release_version }}" >> release-notes.md
        echo "\`\`\`" >> release-notes.md
        echo "" >> release-notes.md

        echo "### NPM" >> release-notes.md
        echo "" >> release-notes.md
        echo "\`\`\`bash" >> release-notes.md
        echo "npm install parsify@${{ needs.validate-release.outputs.release_version }}" >> release-notes.md
        echo "\`\`\`" >> release-notes.md
        echo "" >> release-notes.md

        echo "## ðŸ”— Links" >> release-notes.md
        echo "" >> release-notes.md
        echo "- [Documentation](https://docs.parsify.dev)" >> release-notes.md
        echo "- [GitHub Repository](${{ github.server_url }}/${{ github.repository }})" >> release-notes.md
        echo "- [Issue Tracker](${{ github.server_url }}/${{ github.repository }}/issues)" >> release-notes.md

        # Add contributors
        echo "" >> release-notes.md
        echo "## ðŸ‘¥ Contributors" >> release-notes.md
        echo "" >> release-notes.md
        git log --pretty=format:"- [%an](${{ github.server_url }}/%n)" $COMMIT_RANGE --no-merges | sort -u >> release-notes.md || true

    - name: Generate technical details
      run: |
        cat >> release-notes.md << EOF

        ## ðŸ”§ Technical Details

        ### Build Information
        - **Node.js Version**: $(node --version)
        - **Package Manager**: pnpm $(pnpm --version)
        - **Build Time**: $(date -u +%Y-%m-%dT%H:%M:%SZ)

        ### Checksums
        EOF

        # Generate checksums for release files (will be added after artifacts are created)
        echo "Checksums will be added after release files are generated..." >> release-notes.md

    - name: Upload release notes
      uses: actions/upload-artifact@v3
      with:
        name: release-notes
        path: release-notes.md
        retention-days: 30

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-release, generate-release-notes]
    if: needs.validate-release.outputs.should_release == 'true'

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        path: release-downloads

    - name: Download release notes
      uses: actions/download-artifact@v3
      with:
        name: release-notes
        path: ./

    - name: Generate checksums
      run: |
        echo "## ðŸ” Checksums" >> checksums.md
        echo "" >> checksums.md
        echo "| File | SHA256 |" >> checksums.md
        echo "|------|--------|" >> checksums.md

        # Generate checksums for all release files
        find release-downloads -name "*.tar.gz" -type f | while read file; do
          filename=$(basename "$file")
          checksum=$(sha256sum "$file" | cut -d' ' -f1)
          echo "| $filename | \`$checksum\` |" >> checksums.md
        done

        # Append checksums to release notes
        echo "" >> release-notes.md
        cat checksums.md >> release-notes.md

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.validate-release.outputs.release_version }}
        release_name: Release ${{ needs.validate-release.outputs.release_version }}
        body_path: release-notes.md
        draft: false
        prerelease: ${{ needs.validate-release.outputs.is_prerelease }}

    - name: Upload release assets
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        RELEASE_ID=$(gh release view ${{ needs.validate-release.outputs.release_version }} --json id --jq '.id')

        # Upload all release files
        find release-downloads -name "*.tar.gz" -type f | while read file; do
          echo "Uploading $(basename "$file")..."
          gh release upload ${{ needs.validate-release.outputs.release_version }} "$file" --clobber
        done

        # Upload build info files
        find release-downloads -name "build-info-*.json" -type f | while read file; do
          echo "Uploading $(basename "$file")..."
          gh release upload ${{ needs.validate-release.outputs.release_version }} "$file" --clobber
        done

  deploy-release:
    name: Deploy Release
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release]
    if: needs.validate-release.outputs.should_release == 'true' && (github.event.inputs.deploy_to_production == 'true' || github.event_name == 'push')
    environment:
      name: production
      url: https://parsify.dev

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: web-release-build
        path: web-release

    - name: Download API build artifacts
      uses: actions/download-artifact@v3
      with:
        name: api-release-build
        path: api-release

    - name: Deploy to production
      run: |
        echo "Deploying release ${{ needs.validate-release.outputs.release_version }} to production..."

        # Add your deployment commands here
        # Example:
        # rsync -avz web-release/*.tar.gz production-server:/var/www/releases/
        # rsync -avz api-release/*.tar.gz production-server:/var/www/api-releases/
        #
        # ssh production-server "
        #   cd /var/www/releases &&
        #   tar -xzf parsify-${{ needs.validate-release.outputs.release_version }}.tar.gz &&
        #   ln -sfn parsify-${{ needs.validate-release.outputs.release_version }} current &&
        #   systemctl reload nginx
        # "

        echo "âœ… Release deployed to production"

    - name: Health check
      run: |
        echo "Performing health check after deployment..."
        sleep 15

        # curl -f https://parsify.dev/health || exit 1
        # curl -f https://api.parsify.dev/health || exit 1

        echo "âœ… Health check passed"

  notify-release:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release, deploy-release]
    if: always() && needs.validate-release.outputs.should_release == 'true'

    steps:
    - name: Create release notification
      uses: actions/github-script@v6
      with:
        script: |
          const releaseStatus = needs.create-github-release.result === 'success' ? 'âœ… succeeded' : 'âŒ failed';
          const deployStatus = needs.deploy-release.result === 'success' ? 'âœ… succeeded' : needs.deploy-release.result === 'failure' ? 'âŒ failed' : 'â­ï¸ skipped';
          const version = '${{ needs.validate-release.outputs.release_version }}';
          const isPrerelease = '${{ needs.validate-release.outputs.is_prerelease }}' === 'true';

          const title = `ðŸš€ Release ${releaseStatus}: ${version}${isPrerelease ? ' (Pre-release)' : ''}`;

          let body = `
          ## Release Summary

          **Version**: ${version}
          **Type**: ${isPrerelease ? 'Pre-release' : 'Production Release'}
          **Status**: Release ${releaseStatus}, Deployment ${deployStatus}
          **Commit**: ${{ needs.validate-release.outputs.commit_sha }}
          **Release Time**: ${new Date().toISOString()}

          ### Components
          `;

          if (needs.create-github-release.result === 'success') {
            body += '- âœ… GitHub Release: [View Release](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${version})\n';
          } else {
            body += '- âŒ GitHub Release: Failed\n';
          }

          if (needs.deploy-release.result === 'success') {
            body += '- âœ… Production Deployment: [Live at https://parsify.dev](https://parsify.dev)\n';
          } else if (needs.deploy-release.result === 'failure') {
            body += '- âŒ Production Deployment: Failed\n';
          } else {
            body += '- â­ï¸ Production Deployment: Skipped\n';
          }

          body += `
          ### Next Steps

          ${needs.create-github-release.result === 'success' ? '- [ ] Update documentation\n- [ ] Announce to users\n- [ ] Monitor performance' : '- [ ] Fix release issues and retry'}

          [View Workflow](${context.payload.repository.html_url}/actions/runs/${context.runId})
          `;

          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body,
            labels: ['release', version.includes('alpha') || version.includes('beta') ? 'pre-release' : 'production']
          });

    - name: Notify on Slack (optional)
      if: always()
      run: |
        RELEASE_STATUS="${{ needs.create-github-release.result == 'success' && 'SUCCESS' || 'FAILED' }}"
        VERSION="${{ needs.validate-release.outputs.release_version }}"

        # curl -X POST -H 'Content-type: application/json' \
        #   --data "{\"text\":\"ðŸš€ Release $RELEASE_STATUS\\n\\nVersion: $VERSION\\nRepository: ${{ github.repository }}\\nTime: $(date -u)\\n\\n${{ needs.create-github-release.result == 'success' && 'https://github.com/' + github.repository + '/releases/tag/' + version || '' }}\"}" \
        #   ${{ secrets.SLACK_WEBHOOK_URL_RELEASES }}
        echo "Slack notification: Release $RELEASE_STATUS for $VERSION"

    - name: Update version badge (optional)
      if: needs.create-github-release.result == 'success'
      run: |
        echo "Would update version badge in README to ${{ needs.validate-release.outputs.release_version }}"
        # You could update a version badge or status in your README here

  rollback-release:
    name: Rollback Release (if needed)
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release, deploy-release]
    if: failure() && needs.deploy-release.result == 'failure'
    environment: production

    steps:
    - name: Rollback failed release
      run: |
        echo "ðŸš¨ Release deployment failed - initiating rollback..."
        echo "Version: ${{ needs.validate-release.outputs.release_version }}"

        # Add your rollback logic here
        # Example:
        # if command -v kubectl &> /dev/null; then
        #   kubectl rollout undo deployment/parsify-web
        #   kubectl rollout undo deployment/parsify-api
        # fi

        echo "Rollback completed"

    - name: Notify rollback
      uses: actions/github-script@v6
      with:
        script: |
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ðŸš¨ RELEASE ROLLED BACK: ${{ needs.validate-release.outputs.release_version }}`,
            body: `## Release Rollback

            The deployment for version ${{ needs.validate-release.outputs.release_version }} has failed and been rolled back.

            **Failed Version**: ${{ needs.validate-release.outputs.release_version }}
            **Commit**: ${{ needs.validate-release.outputs.commit_sha }}
            **Rollback Time**: ${new Date().toISOString()}

            Please investigate the deployment failure before attempting to release again.

            [View Failed Deployment](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ context.runId }})
            `,
            labels: ['release', 'rollback', 'urgent']
          });

  cleanup-release:
    name: Cleanup Release Artifacts
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release, notify-release]
    if: always() && needs.validate-release.outputs.should_release == 'true'

    steps:
    - name: Cleanup old release artifacts
      run: |
        echo "Cleaning up release artifacts..."

        # Remove old release artifacts to save space
        # This is optional but helps with storage management
        echo "Release cleanup completed"
